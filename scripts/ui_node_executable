#!/usr/bin/env python3
from copy import copy
from typing import Dict
import logging
import threading
import uvicorn
from ros_sugar.core.ui_node import UINode, UINodeConfig
from ros_sugar.launch.executable import setup_component, run_component

from ui_node.frontend import FHApp
import ui_node.elements as elements


def main():
    """
    Executable to run a component as a ros node.
    Used to start a node using Launcher
    """
    logging.info("Starting UI Node executable")

    logging.info("Setting up UI node with component configs in UI Node")

    # Start UI helper ROS node in a separate thread
    ros_node: UINode = setup_component(
        list_of_components=[UINode], list_of_configs=[UINodeConfig]
    )  # type: ignore

    component_configs = ros_node.config.components

    fh = FHApp(
        component_configs, ros_node.out_topics, ros_node.in_topics
    )  # inputs and outputs are reversed
    app, _ = fh.get_app()

    ros_thread = threading.Thread(
        target=run_component,
        args=[ros_node],
        daemon=True,
    )
    ros_thread.start()

    # Routes for the app backend
    @app.get("/")
    def _():
        """Serves the main application page."""
        return fh.get_main_page()

    @app.get("/settings/show")
    def _(session):
        """Show the settings tabs"""
        fh.toasting("somemsg", session)
        return fh.get_settings()

    @app.post("/settings/submit")
    async def _(request):
        """Update Settings"""
        # update config
        # update UI
        form_data = await request.form()
        result = ros_node.update_configs(dict(form_data.items()))
        success = all(result.success)
        if not success:
            errors = [e for e in result.error_msg if e]
        return fh.get_main_page()

    # -- WS handling --
    async def log_data(send, data, error=False):
        """Send data to text log"""

        if error:
            await send(
                elements.update_logging_card(
                    fh.outputs_log, f"{data['payload']}", txt_type="error"
                )
            )
        else:
            await send(
                elements.update_logging_card(
                    fh.outputs_log, f"{data['payload']}", txt_type="robot"
                )
            )

    async def on_disconn(session):
        """Message for disconnection"""
        fh.toasting(
            "Disconnected from the robot. Check if the recipe is running or refresh the page",
            session,
            toast_type="success",
        )

    async def on_conn(send):
        """When a client connects, register its callback."""
        logging.info("CONNECTING Websocket...")

        # Callback function for ROS node
        async def websocket_callback(data: Dict):
            # Recieve json style data from node and pass to UI with send
            # Get the output log before adding the robot loading dots
            global current_output_log
            fh.outputs_log = current_output_log
            if data["type"] == "String":
                await log_data(send, data)

            if data["type"] == "error":
                await log_data(send, data, error=True)

        ros_node.attach_websocket_callback(websocket_callback)

    @app.ws("/ws", conn=on_conn, disconn=on_disconn)
    async def _(data, send):
        """WS route for input/output communication with ROS UI Node"""

        for key, val in data.items():
            if isinstance(val, str):
                ros_node.publish_data(topic_name=key, data=val)
                await send(
                    elements.update_logging_card(
                        fh.outputs_log, f"{val}", txt_type="user"
                    )
                )
                # Copy the output log before adding the robot loading dots
                global current_output_log
                current_output_log = copy(fh.outputs_log)
                # Send the robot loading dots
                return elements.update_logging_card_with_loading(fh.outputs_log)

    async def on_conn_stream(ws, send):
        """When a client connects, register its callback."""
        logging.info("CONNECTING Streaming Websocket...")

        # Callback function for ROS node
        async def stream_callback(data: Dict):
            if data["type"] == "Image" or data["type"] == "CompressedImage":
                await ws.send_json(data)

            if data["type"] == "error":
                await log_data(send, data, error=True)

        ros_node.attach_streaming_callback(stream_callback)

    @app.ws("/ws_stream", conn=on_conn_stream)
    async def _():
        """WS route for input/output communication with ROS UI Node"""
        # No stream going to the ROS Node
        pass

    uvicorn.run(app, host="0.0.0.0", port=5001)


if __name__ == "__main__":
    main()
