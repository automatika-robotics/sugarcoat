#!/usr/bin/env python3
from typing import Dict
import logging
import threading
import uvicorn
from ros_sugar.core.ui_node import UINode, UINodeConfig
from ros_sugar.launch.executable import setup_component, run_component

from ui_node.frontend import FHApp
import ui_node.elements as elements


def main():
    """
    Executable to run a component as a ros node.
    Used to start a node using Launcher
    """
    logging.info("Starting UI Node executable")

    # Start UI helper ROS node in a separate thread
    ros_node: UINode = setup_component(
        list_of_components=[UINode], list_of_configs=[UINodeConfig]
    )  # type: ignore

    component_configs = ros_node.config.components

    fh = FHApp(
        component_configs, ros_node.out_topics, ros_node.in_topics
    )  # inputs and outputs are reversed
    app, _ = fh.get_app()

    ros_thread = threading.Thread(
        target=run_component,
        args=[ros_node],
        daemon=True,
    )
    ros_thread.start()

    # Routes for the app backend
    @app.get("/")
    def _():
        """Serves the main application page."""
        return fh.get_main_page()

    @app.get("/settings/show")
    def _():
        """Show the settings tabs"""
        return fh.get_settings()

    @app.post("/settings/submit")
    async def _(request, session):
        """Update Settings"""
        # update config
        # update UI
        form_data = await request.form()
        result = ros_node.update_configs(dict(form_data.items()))
        success = all(result.success)
        logging.info(f"RESULT : {result}")
        if not success:
            (fh.toasting(e, session, "error") for e in result.error_msg if e)
        else:
            fh.toasting('Settings changed successfully', session, 'success')
        return fh.get_main_page()

    # -- WS handling --
    async def log_data(send, data, data_src, is_audio=False):
        """Send data to log"""

        await send(
            elements.update_logging_card(
                fh.outputs_log,
                f"{data['payload']}",
                output_src=data_src,
                is_audio=is_audio,
            )
        )

    async def on_disconn(session):
        """Message for disconnection"""
        fh.toasting(
            "Disconnected from the robot. Check if the recipe is running or refresh the page",
            session,
            toast_type="error",
        )

    async def on_conn(send):
        """When a client connects, register its callback."""
        logging.info("CONNECTING Websocket...")

        # Callback function for ROS node
        async def websocket_callback(data: Dict):
            # Recieve json style data from node and pass to UI with send
            if data["type"] in ["String", "Audio"]:
                is_audio = True if data["type"] == "Audio" else False
                await log_data(send, data, data_src="robot", is_audio=is_audio)
            else:
                await log_data(send, data, data_src=data["type"])

        ros_node.attach_websocket_callback(websocket_callback)

    @app.ws("/ws", conn=on_conn, disconn=on_disconn)
    async def _(data, send):
        """WS route for input/output communication with ROS UI Node"""

        for key, val in data.items():
            if isinstance(val, str):
                ros_node.publish_data(topic_name=key, data=val)
                await send(
                    elements.update_logging_card(
                        fh.outputs_log, f"{val}", output_src="user"
                    )
                )
                # Send the robot loading dots
                return elements.update_logging_card_with_loading(fh.outputs_log)

    async def on_conn_stream(ws, send):
        """When a client connects, register its callback."""
        logging.info("CONNECTING Streaming Websocket...")

        # Callback function for ROS node
        async def stream_callback(data: Dict):
            if data["type"] == "Image" or data["type"] == "CompressedImage":
                await ws.send_json(data)
            else:
                await log_data(send, data, data_src=data["type"])

        ros_node.attach_streaming_callback(stream_callback)

    @app.ws("/ws_stream", conn=on_conn_stream)
    async def _(data, send):
        """WS route for input/output communication with ROS UI Node"""
        logging.info(f"Received on streaming: {data}")
        # Only handle audio data
        if data["type"] == "audio":
            logging.info("Received message: audio bytes")
            import base64

            audio_bytes = base64.b64decode(data["payload"])
            ros_node.publish_data(topic_name=data["key"], data=data["val"])

    uvicorn.run(app, host="0.0.0.0", port=5001)


if __name__ == "__main__":
    main()
