#!/usr/bin/env python3
import json
from typing import Dict
from pathlib import Path
from functools import partial
import argparse
import logging
import threading
import uvicorn
from ros_sugar.launch.executable import setup_component, run_component

from ros_sugar.ui_node import UINode, UINodeConfig
from ros_sugar.ui_node.frontend import FHApp
import ros_sugar.ui_node.elements as elements

import base64
import array
import numpy as np
from rosidl_runtime_py.convert import message_to_ordereddict


def main():
    """
    Executable to run a component as a ros node.
    Used to start a node using Launcher
    """
    logging.info("Starting UI Node executable")

    # Start UI helper ROS node in a separate thread
    ros_node: UINode = setup_component(
        list_of_components=[UINode], list_of_configs=[UINodeConfig]
    )  # type: ignore

    ros_node_config = ros_node.config

    # Get parsed UI elements
    parser = argparse.ArgumentParser()
    parser.add_argument("--ui_input_elements", type=str)
    parser.add_argument("--ui_output_elements", type=str)
    parser.add_argument("--ui_service_clients", type=str)
    args, _ = parser.parse_known_args()  # type: ignore
    additional_input_elements = (
        json.loads(args.ui_input_elements) if args.ui_input_elements else None
    )
    additional_output_elements = (
        json.loads(args.ui_output_elements) if args.ui_output_elements else None
    )
    if args.ui_service_clients:
        ros_node._client_inputs_json = args.ui_service_clients

    fh = FHApp(
        ros_node_config.components,
        ros_node.out_topics,  # Inputs from the client to the ros node
        ros_node.in_topics,  # Outputs to the client from the ros node
        srv_clients_configs=ros_node.srv_clients_inputs_dicts(),
        action_clients_configs=ros_node.action_clients_inputs_dicts(),
        additional_input_elements=additional_input_elements,  # Additional UI input elements from derived packages
        additional_output_elements=additional_output_elements,  # Additional UI output elements from derived packages
        hide_settings_panel=ros_node_config.hide_settings,
    )  # inputs and outputs are reversed
    app, _ = fh.get_app()

    ros_thread = threading.Thread(
        target=run_component,
        args=[ros_node],
        daemon=True,
    )
    ros_thread.start()

    # Routes for the app backend
    @app.get("/")
    def _():
        """Serves the main application page."""
        fh.toggle_settings = False
        return fh.get_main_page()

    @app.get("/settings/show")
    def _():
        """Show the settings tabs"""
        fh.toggle_settings = not fh.toggle_settings
        return fh.get_main_page()

    @app.post("/settings/submit")
    async def _(request, session):
        """Update Settings"""
        # update config
        # update UI
        form_data = await request.form()
        result = ros_node.update_configs(dict(form_data.items()))
        success = all(result.success)
        if not success:
            item_names = list(form_data.keys())
            error_msg = "Error in updating the following settings values: \n"
            for key in range(len(result.success)):
                if not result.success[key]:
                    error_msg += f"{item_names[key + 1]}: {result.error_msg[key]}\n"
            fh.toasting(error_msg, session, "error", duration=100000)
        else:
            fh.toasting("Settings changed successfully", session, "success")
            # Persist the new configuration
            fh.update_configs_from_data(dict(form_data.items()))
        return fh.get_main_page()

    @app.post("/service/call")
    async def _(request, session):
        """Send a ROS2 service call from the client"""
        form_data = await request.form()
        data_dict = dict(form_data.items())
        # Add request to logging card
        elements.update_logging_card(
            fh.outputs_log,
            f"Sending service call: '{data_dict}'",
            data_type="String",
            data_src="user",
        )
        result_code, result = ros_node.send_srv_call(data_dict)
        if not result_code:
            fh.toasting(result, session, "error", duration=100000)
        else:
            fh.toasting(
                f"Service returned response: {result}", session, "info", duration=100000
            )
        # Add response to logging card
        elements.update_logging_card(
            fh.outputs_log,
            f"Service returned response: '{result}'",
            data_type="String",
            data_src="robot",
        )
        return fh.get_main_page()

    @app.post("/action/goal")
    async def _(request, session):
        """Send a ROS2 action goal from the client"""
        form_data = await request.form()
        data_dict = dict(form_data.items())
        action_name = data_dict.get("action_name", "")
        if (
            action_name in fh.action_clients_ft
            and fh.action_clients_ft[action_name].is_active()
        ):
            fh.toasting(
                "Cannot send a new goal while the current goal is still active. Cancel ongoing goal first.",
                session,
                "error",
                duration=100000,
            )
            return fh.get_main_page()
        result_code, result = ros_node.send_action_goal(data_dict)
        if not result_code:
            fh.toasting(result, session, "error", duration=100000)
        else:
            fh.toasting(f"Action goal sent: {result}", session, "info", duration=100000)
            fh.action_clients_ft[action_name].update(
                status="accepted",
                duration=0,
            )
            fh.action_clients_ft[action_name].total_calls += 1
        return fh.get_main_page()

    @app.post("/action/cancel")
    async def _(request, session):
        """Cancel a ROS2 action goal from the client"""
        form_data = await request.form()
        data_dict = dict(form_data.items())
        action_name = data_dict.get("action_name")
        result_code, result = ros_node.cancel_action(action_name)
        if not result_code:
            fh.toasting(result, session, "error", duration=100000)
        else:
            fh.toasting(f"{result}", session, "info", duration=100000)
        return fh.get_main_page()

    # -- WS handling --
    async def log_data(send, data: str, data_type: str, data_src: str):
        """Send data to log"""

        await send(
            elements.update_logging_card(
                fh.outputs_log,
                data,
                data_type,
                data_src,
            )
        )

    async def on_disconn(session):
        """Message for disconnection"""
        fh.toasting(
            "Disconnected from the robot. Check if the recipe is running or refresh the page",
            session,
            toast_type="error",
        )

    async def on_conn_stream(ws, send, topic_type: str):
        """When a client connects, register its callback."""

        # Callback function for ROS node
        async def stream_callback(data: Dict, **_):
            if data["type"] == "error":
                await log_data(
                    send, data["payload"], data_type=data["type"], data_src=data["type"]
                )
            else:
                await ws.send_json(data)

        ros_node.attach_websocket_callback(stream_callback, topic_type)

    async def on_conn_map(ws, _, topic_type: str):
        """When a client connects, register its callback."""

        # Callback function for ROS node
        async def map_callback(*_, msg):
            # Convert ROS message to a JSON-serializable dict
            # Convert header and info normally (they are small)
            msg_dict = {
                "header": message_to_ordereddict(msg.header),
                "info": message_to_ordereddict(msg.info),
            }

            # FAST CONVERSION of data field
            # 'data' is typically a list of int8. We want a Base64 string.
            data_field = msg.data
            raw_bytes = b""

            if isinstance(data_field, list):
                # 'b' is signed char (int8), matches ROS int8[]
                raw_bytes = array.array("b", data_field).tobytes()
            elif isinstance(data_field, array.array):
                raw_bytes = data_field.tobytes()
            elif isinstance(data_field, bytes):
                raw_bytes = data_field
            elif isinstance(data_field, np.ndarray):
                raw_bytes = data_field.tobytes()
            else:
                # Fallback (slowest)
                raw_bytes = bytes(data_field)

            msg_dict["data"] = base64.b64encode(raw_bytes).decode("utf-8")

            response = {"op": "publish", "msg": msg_dict}
            await ws.send_json(response)

        logging.warning(f"attaching with topic type {topic_type}...")
        ros_node.attach_websocket_callback(map_callback, topic_type)

    async def on_conn_action(_, send, action_name: str):
        """When a client connects, register its callback."""

        # Callback function for ROS node
        async def feedback_callback(data: Dict, **_):
            """Updates an action client with new feedback from the server

            :param data: UI data dict (status, feedback, etc.)
            :type data: Dict
            """
            if data["is_new_feedback"]:
                fh.action_clients_ft[action_name].update(
                    status=data["status"],
                    feedback=data["feedback"],
                    duration=data["duration_secs"],
                )
                await send(fh.action_clients)

        ros_node.attach_client_feedback_callback(feedback_callback, action_name)

    # Create websockets for streaming output topics
    for topic_name, topic_type in fh.get_all_stream_outputs():

        @app.ws(
            f"/ws_{topic_name}",
            conn=partial(on_conn_stream, topic_type=topic_type),
            disconn=on_disconn,
        )
        async def _():
            pass

    # Create websockets for map output topics
    for topic_name, topic_type in fh.get_all_map_outputs():
        logging.warning(f"starting map ws for {topic_name}...")

        @app.ws(
            f"/ws_{topic_name}",
            conn=partial(on_conn_map, topic_type=topic_type),
            disconn=on_disconn,
        )
        async def _(_, data):
            # Map websockets send back clicked points (Point, Pose, etc.)
            # The actual point data is in data.data, but it is expected in the ui node directly in data.x, etc.
            if message := data.pop("data", None):
                data.update(message)
                ros_node.publish_data(data)

    for clients_configs_dict in ros_node.action_clients_inputs_dicts():
        logging.warning(
            f"starting action clients ws for {clients_configs_dict['name']}..."
        )

        @app.ws(
            "/ws_actions",
            conn=partial(on_conn_action, action_name=clients_configs_dict["name"]),
            disconn=on_disconn,
        )
        async def _():
            """WS route for sending action feedback to ROS UI Node"""
            pass

    @app.ws("/ws_audio", disconn=on_disconn)
    async def _(data, send):
        """WS route for sending audio to ROS UI Node"""
        # Only handle audio data
        if data["type"] == "audio" and len(data["payload"]) > 0:
            try:
                await log_data(
                    send, data["payload"], data_type="Audio", data_src="user"
                )
                ros_node.publish_data({
                    "topic_name": data["topic_name"],
                    "topic_type": "Audio",
                    "data": data["payload"],
                })
            except RuntimeError:
                logging.warning("Runtime error when sending audio")

            # Send the robot loading dots
            return elements.update_logging_card_with_loading(fh.outputs_log)

    @app.ws("/ws_audio", disconn=on_disconn)
    async def _(data, send):
        """WS route for sending audio to ROS UI Node"""
        # Only handle audio data
        if data["type"] == "audio" and len(data["payload"]) > 0:
            try:
                await log_data(
                    send, data["payload"], data_type="Audio", data_src="user"
                )
                ros_node.publish_data({
                    "topic_name": data["topic_name"],
                    "topic_type": "Audio",
                    "data": data["payload"],
                })
            except RuntimeError:
                logging.warning("Runtime error when sending audio")

            # Send the robot loading dots
            return elements.update_logging_card_with_loading(fh.outputs_log)

    async def on_conn(send):
        """When a client connects, register its callback."""

        # Callback function for ROS node
        async def websocket_callback(data: Dict, **_):
            # Recieve json style data from node and pass to UI with send
            if len(data["payload"]) > 0:
                await log_data(
                    send, data["payload"], data_type=data["type"], data_src="robot"
                )

        ros_node.attach_websocket_callback(websocket_callback)

    @app.ws("/ws", conn=on_conn, disconn=on_disconn)
    async def _(data, send):
        """WS route for input/output communication with ROS UI Node"""

        if (data_type := data.get("topic_type")) == "String":
            # display in log for string data types
            await log_data(send, data["data"], data_type=data_type, data_src="user")
            ros_node.publish_data(data=data)
            # Send the robot loading dots
            return elements.update_logging_card_with_loading(fh.outputs_log)
        elif data.get("topic_type") in ["Point", "PointStamped"]:
            # display in log for coordinates data types
            await log_data(
                send,
                f"Published to topic /{data.get('topic_name')} using coordinates: x={data['x']}, y={data['y']}, z={data['z']}",
                data_type="String",
                data_src="user",
            )
            ros_node.publish_data(data=data)
        elif data.get("topic_type") in ["Pose", "PoseStamped"]:
            # display in log for coordinates data types
            await log_data(
                send,
                f"Published to topic /{data.get('topic_name')} using coordinates: (Position: x={data['x']}, y={data['y']}, z={data['z']}), (Orientation: w={data['ori_w'] or '1'}, x={data['ori_x'] or '0'}, y={data['ori_y'] or '0'}, z={data['ori_z'] or '0'})",
                data_type="String",
                data_src="user",
            )
            ros_node.publish_data(data=data)
        elif data.get("topic_type") == "Bool":
            # display in log for coordinates data types
            await log_data(
                send,
                f"Published to topic /{data.get('topic_name')}: {data.get('data', 'off')}",
                data_type="String",
                data_src="user",
            )
            ros_node.publish_data(data=data)
        else:
            ros_node.publish_data(data=data)

    # Check if SSL certificates exist
    if not (
        Path(ros_node_config.ssl_keyfile).exists()
        and Path(ros_node_config.ssl_certificate).exists()
    ):
        logging.info("\n" + "=" * 80)
        logging.info("WARNING: SSL certificates (key.pem, cert.pem) not found.")
        logging.info(
            "Microphone access will not work when accessing from another machine."
        )
        logging.info(
            "To enable microphone over the network, generate certificates by running"
        )
        logging.info("the following command:")
        logging.info(
            '\nopenssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365 -nodes -subj "/CN=localhost"\n'
        )
        logging.info(
            "And give the path to the certificates to the launcher.enable_ui method"
        )
        logging.info("=" * 80 + "\n")
        key_file = None
        certificate_file = None
        protocol = "http"
    else:
        key_file = ros_node_config.ssl_keyfile
        certificate_file = ros_node_config.ssl_certificate
        protocol = "https"

    logging.info(
        f"Access the recipe UI at: {protocol}://<IP_ADDRESS_OF_THE_ROBOT>:{ros_node_config.port}"
    )
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=ros_node_config.port,
        ssl_keyfile=key_file,
        ssl_certfile=certificate_file,
    )


if __name__ == "__main__":
    main()
