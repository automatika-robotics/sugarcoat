#!/usr/bin/env python3
from copy import copy
import time
from typing import Dict
import logging
import threading
import base64
import cv2
import uvicorn
from ros_sugar.core.ui_node import UINode, UINodeConfig
from ros_sugar.launch.executable import setup_component, run_component

from ui_node.frontend import FHApp
import ui_node.elements as elements


def main():
    """
    Executable to run a component as a ros node.
    Used to start a node using Launcher
    """
    logging.info("Starting UI Node executable")

    logging.info("Setting up UI node with component configs in UI Node")

    # Start UI helper ROS node in a separate thread
    ros_node: UINode = setup_component(
        list_of_components=[UINode], list_of_configs=[UINodeConfig]
    )  # type: ignore

    component_configs = ros_node.config.components

    fh = FHApp(
        component_configs, ros_node.out_topics, ros_node.in_topics
    )  # inputs and outputs are reversed
    app, _ = fh.get_app()

    ros_thread = threading.Thread(
        target=run_component,
        args=[ros_node],
        daemon=True,
    )
    ros_thread.start()

    # Routes for the app backend
    @app.get("/")
    def main_page():
        """Serves the main application page."""
        return fh.get_main_page()

    @app.get("/settings/show")
    def settings_show(session):
        fh.toasting("somemsg", session)
        return fh.get_settings()

    @app.post("/settings/submit")
    async def settings_submit(request):
        # update config
        # update UI
        form_data = await request.form()
        result = ros_node.update_configs(dict(form_data.items()))
        success = all(result.success)
        if not success:
            errors = [e for e in result.error_msg if e]
        return fh.get_main_page()

    # -- WS handling --
    async def on_disconn(session):
        """When a client disconnects, unregister its callback."""
        fh.toasting("Disconnected from the robot. Check if the recipe is running or refresh the page", session, toast_type="success")

    async def on_conn(send):
        """When a client connects, register its callback."""
        logging.info("CONNECTING Websocket...")

        # Callback function for ROS node
        async def websocket_callback(data: Dict):
            # Recieve json style data from node and pass to UI with send
            # Get the output log before adding the robot loading dots
            global current_output_log
            fh.outputs_log = current_output_log
            if data["type"] == "String":
                await send(
                    elements.update_logging_card(
                        fh.outputs_log, f"{data['payload']}", txt_type="robot"
                    ),
                )
            if data["type"] == "Image" or data["type"] == "CompressedImage":
                try:
                    # Encode image as JPEG
                    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), 90]
                    result, buffer = cv2.imencode(
                        ".jpg", data["payload"], encode_param
                    )
                    if not result:
                        logging.error("Failed to encode image to JPEG format.")
                        await send(
                            elements.update_logging_card(
                                fh.outputs_log,
                                "Failed to encode image to JPEG format",
                                txt_type="error",
                            ),
                        )

                    # Convert to base64
                    jpg_as_text = base64.b64encode(buffer).decode("utf-8")
                    logging.info("Received image")
                    # TODO: Display image here
                    await send(elements.make_image(jpg_as_text))

                except Exception as e:
                    logging.error(f"Failed to encode image frame: {e}")

            if data["type"] == "error":
                await send(
                    elements.update_logging_card(
                        fh.outputs_log, f"{data['payload']}", txt_type="error"
                    ),
                )

        ros_node.attach_websocket_callback(websocket_callback)

    @app.ws("/ws", conn=on_conn, disconn=on_disconn)
    async def ws(data, send):
        """WS route for input/output communication with ROS UI Node"""

        logging.info(f"Data: {data}")
        for key, val in data.items():
            if isinstance(val, str):
                ros_node.publish_data(topic_name=key, data=val)
                await send(elements.update_logging_card(fh.outputs_log, f"{val}", txt_type="user"))
                # Copy the output log before adding the robot loading dots
                global current_output_log
                current_output_log = copy(fh.outputs_log)
                # Send the robot loading dots
                return elements.update_logging_card_with_loading(fh.outputs_log)

    uvicorn.run(app, host="0.0.0.0", port=5001)


if __name__ == "__main__":
    main()
